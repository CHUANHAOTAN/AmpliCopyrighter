#!/usr/bin/env perl

# trait_by_clade_weighted
# Copyright 2012-2014 Adam Skarshewski
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade_weighted - Summarize a trait at different taxonomic levels using weighted average

=head1 SYNOPSIS

  trait_by_clade_weighted -f trait.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and calculates its weighted average
at all taxonomic levels.

By weighted, we mean that the trait value for each clade is given the same
weight, regardless of how many sequenced genomes the trait was estimated for.
This is  to prevent clade with many sequenced representative to get a disproportionately large importance compared to clades that have few.

=head1 REQUIRED ARGUMENTS

=over

=item -i <input_file>

Input file of tab-delimited traits. This file should have been generated by the
script data_combiner. This script will use the columns called 'GG ID' and 'GG Tax'.

=for Euclid:
   input_file.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -t <trait_name>

If the input file contains several traits, select the name of the trait to use
(case-insensitive), e.g. '16S rRNA Count' or 'Genome Size'. Make sure this matches
the name of the trait as found in the input file. Default: trait_name.default

=for Euclid:
   trait_name.type: string
   trait_name.default: '16S rRNA Count'

=item -a <advanced>

Use advanced output: 1 is yes, 0 is no. The basic output is a tab-delimited file
with two columns, suitable for use in Copyrighter: Taxonomy, Mean. The advanced
output contains additional information distributed over four columns: Taxonomy,
Num, Mean, Stddev. Default: advanced.default

=for Euclid:
   advanced.type: integer, advanced == 0 || advanced == 1
   advanced.default: 0

=back

=head1 AUTHORS

Florent Angly <florent.angly@gmail.com>

Adam Skarshewski

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012-2014 Adam Skarshewski

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use List::Util qw(sum);
use Method::Signatures;
use Getopt::Euclid qw(:minimal_keys);
use Statistics::Basic qw(mean stddev);
use FindBin qw($Bin);
use lib "$Bin";
use PreprocUtils;

$Statistics::Basic::IPRES = 14;

trait_by_clade_weighted( $ARGV{'i'}, $ARGV{'p'}, $ARGV{'a'} );
exit;

func trait_by_clade_weighted ( $input_file, $trait_name, $advanced ) {

   open my $fh, '<', $input_file or die "Error: Could not read file $input_file\n$!\n";

   my $header = <$fh>;
   chomp $header;
   my @cols = PreprocUtils::find_column_for($header,
      'GG ID', 'GG Tax', $trait_name);
   warn "Info: Found trait '$trait_name' in column ".($cols[-1]+1)."\n";

   # Parse input file
   my @dereplication = ({}, {}, {}, {}, {}, {}, {});
   while (my $line = <$fh>) {
      chomp $line;
      my ($gg_id, $gg_tax, $trait_val) = (split /\t/, $line)[@cols];
      my @gg_splittax  = split /;\s*/, $gg_tax;
      if ( (scalar @gg_splittax == 1) && ($gg_splittax[0] =~ m/^-?$/) ) {
         # Skip entry with missing taxonomy string
         next;
      } elsif (scalar @gg_splittax != 7) {
         # Skip entries with malformed taxonomy string
         warn "Warning: Taxonomy string at line $. did not have 7 fields as expected. Skipping...\n";
         next;
      }
      # As we are averaging nodes of nodes, we want no taxonomy w missing data
      if (my $bob = sum(map {$_ =~ /__$/} @gg_splittax)) {
         next;
      }
      my $derep_str = join ';', @gg_splittax[0..6];
      push @{$dereplication[6]->{$derep_str}}, $trait_val;
   }
   close $fh;

   if (defined $phylo_tree) {
      pic($phylo_tree);
   } else {
      # Calculate averages at all taxonomic levels
      for (my $i = 5; $i >= 0; $i--) {
         my $tlvl = $dereplication[$i];                                 # this level
         while (my ($low_tax, $low_r) = each %{$dereplication[$i+1]}) { # lower level
            my @split_low_tax = split /;\s*/, $low_tax;
            my $this_tax = join ';', @split_low_tax[0..$#split_low_tax-1];
            push @{$tlvl->{$this_tax}}, mean(@$low_r);
         }
      }
   }

   # Writing results
   my @fields;
   if ($advanced) {
      @fields = ('# Taxonomy', 'Num', 'Mean', 'Stddev');
   } else {
      @fields = ('# Taxonomy', 'Mean');
   }
   print join("\t", @fields)."\n";
   for my $rank_hash_ptr (@dereplication) {
      for my $tax (sort {$a cmp $b} keys %{$rank_hash_ptr}) {
         my @vals = @{$rank_hash_ptr->{$tax}};
         my @stats;
         if ($advanced) {
            @stats = ($tax, scalar(@vals), mean(@vals), stddev(@vals));
         } else {
            @stats = ($tax, mean(@vals));
         }
         print join("\t", @stats)."\n";
      }
      print "\n";
   }

   return 1;
}

