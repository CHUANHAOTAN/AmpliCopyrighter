#! /usr/bin/env perl

# img_gg_matcher
# Copyright 2012 Florent Angly
# You may distribute this module under the terms of the GPLv3


=head1 NAME

img_gg_matcher - Find the Greengenes ID for IMG IDs that miss it

=head1 SYNOPSIS

  img_gg_matcher -c img_to_gg.txt -i img_metadata.txt -s gg_12_10.fasta > updated_correspondances.txt

=head1 DESCRIPTION

Given a file of correspondances between IMG IDs and Greengenes ID, remove
eukaryotic IDs (Greengenes contains no eukaryotes), and try to find some of the
missing Greengenes IDs using two
methods:

=over

=item 1/

By matching names (fast). See the <desc> and <names> options.

=item 2/

By matching sequences very stringently (using BLAT, slower). See the <rrna> option.

=back

The results are written to screen in a format similar to that of the correspondance
file.

=head1 REQUIRED ARGUMENTS

=over

=item -c <corr_file>

Specify the IMG-Greengenes correspondance file. The tab-delimited correlation file
contains these columns: IMG ID (taxon_oid), GG ID. Some of these
correspondances can be extracted from IMG (http://img.jgi.doe.gov/) and GOLD
(http://www.genomesonline.org/).

=for Euclid:
   corr_file.type: readable

=item -i <img_file>

Provide an IMG metadata file can be obtained using the export function of IMG
(http://img.jgi.doe.gov/). It should have tab-delimited columns, with at least
these columns: taxon_oid, Domain, Genome Name.

=for Euclid:
   img_file.type: readable

=item -s <seq_file>

FASTA file of Greengenes 16S rRNA sequences, such as the one that can be
downloaded from the SecondGenome website at L<ftp://greengenes.microbio.me/greengenes_release/gg_12_10/gg_12_10.fasta.gz>.

=for Euclid:
   seq_file.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -d <desc>

Look up names of species in the Greengenes FASTA file (sequence description
field) and if an organism similar enough (at least at species level, but maybe
not quite at subspecies or strain level), take its Greengenes ID. The sequence
headers should look like this:

  >20 AF025822.1 Methanococcus infernus k__Archaea; p__Euryarchaeota; c__Methanococci; o__Methanococcales; f__Methanocaldococcaceae; g__Methanocaldococcus; otu_139

This method will work with Greengenes 2011 and before. Values: 1 for yes, 0 for
no. Default: desc.default

=for Euclid:
   desc.type: integer, desc == 0 || desc == 1
   desc.default: 0

=item -n <names>

Similar to <desc> but provide a file that has the names of the Greengenes
isolates. This is suitable for Greengenes 2012 and later. Get the GG SQL file, 
convert it to Sqlite using mysql2sqlite.pl from L<http://stackoverflow.com/a/9857906/1050730>.
Then run: sqlite -header gg_12_10.sqlite "select gg_id, organism, strain from greengenes where decision='named_isolate';" > gg_named_isolates.txt
Use the output file as input for this option.

=for Euclid:
   names.type: readable

=item -r <rrna>

Match the IMG 16S rRNA sequences in the provided file and compare them to
sequences in the Greengenes database (<seq_file> option). Take the Greengenes ID
of the first highly similar sequence. Using this option can increase runtime
significantly.... be patient. Note that in addition to standard FASTA
headers, this file can have a more specific header that includes an IMG genome
ID, an underscore and an IMG gene ID, e.g.:

  >640753060_640862969

=for Euclid:
   rrna.type: string

=back

=head1 AUTHOR

Florent Angly <florent.angly@gmail.com>

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Florent Angly

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use List::Util qw(min);
use Method::Signatures;
use Getopt::Euclid qw(:minimal_keys);
use Bio::DB::Fasta;
use Bio::SeqIO;


img_gg_matcher( $ARGV{'c'}, $ARGV{'i'}, $ARGV{'s'}, $ARGV{'d'}, $ARGV{'n'}, $ARGV{'r'} );
exit;


func img_gg_matcher ( Str $corr_file, Str $img_file, Str $seq_file,
   $search_desc, $search_names, $search_seqs ) {

   # Parse correspondance file, identify some missing IDs
   my ($correlations, $missing) = read_correspondances($corr_file);

   # Parse metadata, update list of missing IDs
   (my $names, $correlations, $missing) = read_metadata($img_file, $correlations,
      $missing);

   warn "Info: There are ".(scalar keys %$missing)." IMG IDs with missing GG ID.\n";

   # Exclude anything that is not a bacteria or archaea
   if ( (scalar keys %$missing > 0) && ($search_desc || $search_names || $search_seqs) ) {

      # Index FASTA file and sort genome names by taxa
      my ($db, $ids) = index_fasta($seq_file);
      my $gg_taxa    = gg_id_by_taxa($db, $search_desc, $search_names);

      # Find a matching name
      if ($search_desc || $search_names) {
         ($correlations, $missing) = match_names($names, $correlations, $missing,
            $gg_taxa);
         warn "Info: There are still ".scalar(keys(%$missing))." missing IDs\n";
      }

      # Find a perfectly matching sequence
      if ($search_seqs) {
         ($correlations, $missing) = match_sequences($correlations, $missing,
             $search_seqs, $seq_file);
         warn "Info: There are still ".scalar(keys(%$missing))." missing IDs\n";
      }

   }

   write_correspondances($correlations);

   return 1;
}


func match_sequences ($correlations, $missing, $img_fasta, $gg_fasta) {
   # Run BLAT and only get very stringent similarities (no more than a couple bp
   # different)
   #   query : Greengenes 16S sequences
   #   target: IMG 16S sequences

   my $min_identity = 99.8;
   my $min_coverage = 99.8;

   my $out_file = 'match_sequences.blat';
   my $matches;
   if (-e $out_file) {
      warn "Info: Not re-running BLAT. Using existing BLAT results $out_file\n";
      ($matches, undef) = read_correspondances($out_file);
   } else {
      warn "Info: Running BLAT...\n";
      my $db_fasta = $gg_fasta;
      my $query_fasta = filter_fasta($img_fasta, $missing);
      my $report = run_blat($query_fasta, $db_fasta, $min_identity);
      unlink $query_fasta;
      $matches = parse_blat_results($report, $min_identity, $min_coverage, $out_file);
      warn "Info: Done running BLAT...\n";
   }

   my $num_matches = 0;
   while ( (my $img_id, undef) = each %{$missing} ) {
      warn sprintf( "Info: Searching for sequence match for IMG ID %12s ... %s\n", $img_id, '');
      if (exists $matches->{$img_id}) {
         my $gg_id = $matches->{$img_id};
         $correlations->{$img_id} = $gg_id;
         delete $missing->{$img_id};
         $num_matches++;
         warn sprintf("Info: Found   great sequence match,     GG ID %12s ... %s\n", $gg_id, '');
      }
   }

   warn "Info: Found sequence match for $num_matches IMG IDs ".($num_matches > 0 ? ':D' : ':(((')."\n";
   return $correlations, $missing;
}


func filter_fasta ($in_fasta_file, $ids) {
   # Write a new FASTA file with only the sequence from the specified IDs in.
   my $out_fasta_file = $in_fasta_file.'.temp';
   my $in  = Bio::SeqIO->new( -file => '<'.$in_fasta_file , -format => 'fasta' );
   my $out = Bio::SeqIO->new( -file => '>'.$out_fasta_file, -format => 'fasta' );
   while (my $seq = $in->next_seq) {
      my $id = extract_img_id( $seq->id );
      if (exists $ids->{$id}) {
         # Write this sequence
         $out->write_seq($seq);
      }
   }
   $in->close;
   $out->close;
   return $out_fasta_file;
}


func run_blat ($query_fasta, $db_fasta, $min_identity) {
   # Run Blat
   eval { require Bio::Tools::Run::Alignment::Blat; };
   if ($@) {
      die "Error: Could not find module required for BLAT search, ".
         "Bio::Tools::Run::Alignment::Blat. You need to install bioperl-run!\n";
   }
   my $factory = Bio::Tools::Run::Alignment::Blat->new(
      -db          => $db_fasta,
      -minIdentity => $min_identity,
      #-fastMap    => 1, # not so good to find matches with a few errors
   );
   my $report = $factory->run($query_fasta);
   return $report;
}


func parse_blat_results ( $report, $min_identity, $min_coverage, $out_file ) {
   # Parse BLAT results and save correspondances
   my %matches;
   my ($genome_id, $genome_best_score, $genome_best_target);
   open my $out, '>', $out_file or die "Error: Could not write results in file $out_file\n$!\n";
   QUERY: while (my $result = $report->next_result) {
 
      my $query_id     = extract_img_id( $result->query_name );
      my $query_length = $result->query_length;

      # Save results and reset some variables if we are looking at a new genome
      if ( (not defined $genome_id) or (not $genome_id eq $query_id) ) {
         $matches{$genome_id} = $genome_best_target;
         print $out "$genome_id\t$genome_best_target\n";
         ($genome_id, $genome_best_score, $genome_best_target) = ($query_id, undef, undef);
      }

      # Go through hits by decreasing bit score
      HIT: for my $hit ( sort { $b->raw_score <=> $a->raw_score } $result->hits ) {
         my $target_length = $hit->length;
         my $target_score  = $hit->raw_score;
         #print "   Target ".$hit->name." (bitscore: ".$hit->raw_score ."): $target_length bp\n";

         while ( my $hsp = $hit->next_hsp ) {

            my $hsp_num_ident  = $hsp->num_identical;
            my $hsp_perc_ident = $hsp_num_ident / min($query_length, $target_length) * 100;
            #print "      NumIdentical=$hsp_num_ident  PercentId=$hsp_perc_ident\n";
            next if $hsp_perc_ident < $min_coverage;

            my $hsp_length     = min($hsp->length('query'), $hsp->length('hit'));
            my $hsp_coverage   = $hsp_length / $query_length * 100;
            #print "      Length=$hsp_length  Coverage=$hsp_coverage\n";
            next if $hsp_coverage < $min_coverage;

            if ( ($hsp_coverage >= $min_coverage) && ($hsp_perc_ident >= $min_identity) ) {
               # Store hit
               #print "      KEEP ME\n";
               if ($target_score > $genome_best_score) {
                  ($genome_best_target, $genome_best_score) = ($hit->name, $target_score);
               }
               last HIT;
            }

            if ( ($hsp_coverage < $min_coverage) && ($hsp_perc_ident < $min_identity) ) {
               # All hits after this one will have a smaller bitscore.
               # So, we're done. This query sequence has no satisfactory hit.
               last HIT;
            }

         }  
      }
      #print "\n";
   }

   # Save results for last genome
   $matches{$genome_id} = $genome_best_target;
   print $out "$genome_id\t$genome_best_target\n";

   close $out;
   return \%matches;
}


func index_fasta (Str $fasta_file, $temp = 0, $makeid?) {
   # Index the FASTA file for random access
   my $args = $temp ? {-reindex => 1, -clean => 1} : {-reindex => 0, -clean => 0};
   if (defined $makeid) {
      $args->{-makeid} = $makeid;
   }
   my $db = Bio::DB::Fasta->new( $fasta_file, $args );
   my @ids = $db->get_all_primary_ids;
   my $num = scalar @ids;
   warn "Info: Read $num sequences from file $fasta_file.\n";
   return $db, \@ids;
}


func parse_name ( Str $name ) {
   my $tmp_name = $name;
   my ($candidatus, $genus, $species, $strain) = ('', '', '', '');
   if ($name =~ m/^[A-Z]/) {
      # Proper scientific name is always capitalized.
      # Other names are not, e.g. 'contaminated aquifer clone WCHD3-33'

      # Remove trailing spaces (if any)
      $tmp_name   =~ s/\s*$//;
      $tmp_name   =~ s/^\s*//;

      # Fix missing spaces, as in 'Rhodobacterales sp.HTCC2255' or 'Halobacterium sp.Ch2'
      $tmp_name   =~ s/\b((?:genomo)?(?:sp|spp|species|cf)\.)([a-z0-9])/species $2/gi;

      # Expand some acronyms
      $tmp_name   =~ s/\b(?:genomo)?(?:sp|spp|species|cf)\.?\s/species /gi;
      $tmp_name   =~ s/\b(?:sub|ssp|subsp|subspecies)\.?\s/subspecies /gi;
      $tmp_name   =~ s/\b(?:str|st|strain)\.?\s/strain /gi;
      $tmp_name   =~ s/\b(?:var)\.?\s/var /gi;
      $tmp_name   =~ s/\b(?:sv|serovar)\.?\s/serovar /gi;
      $tmp_name   =~ s/\b(?:bv|biovar)\.?\s/biovar /gi;
      $tmp_name   =~ s/\b(?:pv|pathovar)\.?\s/pathovar /gi;
      $tmp_name   =~ s/\b(?:cv|cultivar)\.?\s/cultivar /gi;
      $tmp_name   =~ s/\b(?:gv|genomovar)\.?\s/genomovar /gi;
      $tmp_name   =~ s/\b(?:mv|morphovar)\.?\s/morphovar /gi;

      # Replace 'ATCC1234' or 'ATCC_1234'by 'ATCC 1234', etc
      our $catalogs = 'ACM|AJ|ATCC|BCRC|BKME|CBMAI|CCEB|CCM|CCMP|CCRC|CCRI|CCT|CCTM|'.
         'CCUG|CDBB|CECT|CFBP|CGMCC|CIP|CNCTC|DSM|DSMZ|GIFU|GISK|GTC|HAMBI|HSCC|HTCC|IAM|'.
         'ICMP|ICS|IFO|IMAU|IMCC|IMET|JCM|KACC|KCTC|KS|LMD|LMG|MIT|NBRC|NCAIM|NCCB|NCDO|NCFB|NCIB|'.
         'NCIM|NCIMB|NCTC|NRRL|NRRL NRSNRS|PCC|PCM|PZH|RCC|RH|TSNRS|USCC|USDA|VTT E';
      $tmp_name   =~ s/\b($catalogs)(?:-|_|\.|)(\d+)/$1__$2/gi;  #  Add the separator, remove it later, after massage

      # Candidatus
      $tmp_name   =~ s/^(Candidatus)\s+//gi;
      $candidatus = $1 || '';

      # Genus
      $tmp_name   =~ s/^(\S+)\s*//gi;
      $genus      = $1 || '';

      # Species
      if ($tmp_name  =~ m/^\s*(?:subspecies|strain|var|serovar|biovar|pathovar|cultivar|genomovar|morphovar)\s*/gi) {
         $species    = ''
      } else {
         $tmp_name   =~ s/^(\S+)\s*//gi;
         $species    = $1 || '';
         $species    =~ s/^\s*species\s*$//gi;
      }

      # Strain (in a broad sense)
      $strain     = $tmp_name || '';

   }
   return $candidatus, $genus, $species, $strain;
}


func massage_strain ( Str $strain ) {
   # Remove some common strings from strain name
   $strain =~ s/\b(?:strain|subspecies|var|serovar|biovar|pathovar|cultivar|genomovar|morphovar)\s*//gi;
   our $catalogs = 'ACM|AJ|ATCC|BCRC|BKME|CBMAI|CCEB|CCM|CCMP|CCRC|CCRI|CCT|CCTM|'.
      'CCUG|CDBB|CECT|CFBP|CGMCC|CIP|CNCTC|DSM|DSMZ|GIFU|GISK|GTC|HAMBI|HSCC|HTCC|IAM|'.
      'ICMP|ICS|IFO|IMAU|IMCC|IMET|JCM|KACC|KCTC|KS|LMD|LMG|MIT|NBRC|NCAIM|NCCB|NCDO|NCFB|NCIB|'.
      'NCIM|NCIMB|NCTC|NRRL|NRRL NRSNRS|PCC|PCM|PZH|RCC|RH|TSNRS|USCC|USDA|VTT E';
   $strain =~ s/\b(?:$catalogs)\s//gi;
   # Remove some non-text characters
   $strain =~ s/(?:,|;) / /gi;
   $strain =~ s/\s+/ /gi;

   #      replace / ( ) = by ''  
   #       split on ,
   #       then split on ' '

   return $strain;
}


func match_name ( Str $img_name, $genera ) {
   my ($msg, $good_id, $good_scientific);

   my ($candidatus, $genus, $species, $strain) = parse_name($img_name);
   my $strain_clean = massage_strain( $strain );
   #warn "                                                    ".
   #     "| $genus | $species | $strain | $strain_clean |\n";

   # Look for perfect genus, species and strain match
   while ( my ($gg_id, $gg_names) = each %{$genera->{$genus}->{$species}->{$strain}} ) {
      my ($gg_scientific, $gg_strain_clean) = @$gg_names;
      $good_id = $gg_id;
      $good_scientific = $gg_scientific;
      $msg = sprintf "Info: Found perfect name match,     GG ID %12s ... %s\n", $good_id, $good_scientific;
      last;
   }


   # Look for perfect genus and species match, but approximate strain match
   if (not defined $good_id) {
      LOOKUP: while ( my ($gg_strain, $gg_hash) = each %{$genera->{$genus}->{$species}} ) {
         while ( my ($gg_id, $gg_names) = each %{$gg_hash} ) {
            my ($gg_scientific, $gg_strain_clean) = @$gg_names;
            # Try matching massaged strain name
            # Example: Lactobacillus casei LC2W
            #          Lactobacillus casei str. LC2W 
            if ($strain_clean eq $gg_strain_clean) {
               $good_id = $gg_id;
               $good_scientific = $gg_scientific;
               $msg = sprintf "Info: Found   great name match,     GG ID %12s ... %s\n", $good_id, $good_scientific;
               last LOOKUP;
            }

            #warn "                                                    ".
            #     "+ $genus + $species + $gg_strain + $gg_strain_clean +\n";

            # Match one part of the strain name only
            # Example: Prochlorococcus marinus MIT9202
            #          Prochlorococcus marinus MIT 9202 str. MIT9202 str.
            for my $gg_elem ( split ' ', $gg_strain_clean ) {
               next if length $gg_elem < 4; # Skip short elements
               for my $elem ( split ' ', $strain_clean ) {
                  next if length $elem < 4;
                  if ($gg_elem eq $elem) {
                     $good_id = $gg_id;
                     $good_scientific = $gg_scientific;
                     $msg = sprintf "Info: Found    good name match,     GG ID %12s ... %s\n", $good_id, $good_scientific;
                     last LOOKUP;
                  }
               }
            }

            # Match one part of the strain name only, this time without ATCC and co
            for my $gg_elem ( split ' ', $gg_strain_clean ) {
               $gg_elem =~ s/\S+__//g;
               next if length $gg_elem < 4; # Skip short elements
               for my $elem ( split ' ', $strain_clean ) {
                  $elem =~ s/\S+__//g;
                  next if length $elem < 4;
                  if ($gg_elem eq $elem) {
                     $good_id = $gg_id;
                     $good_scientific = $gg_scientific;
                     $msg = sprintf "Info: Found    good name match,     GG ID %12s ... %s\n", $good_id, $good_scientific;
                     last LOOKUP;
                  }
               }
            }

         }
      }
   }
   warn $msg if $msg;
   return $good_id, $good_scientific;
}


func extract_gg_name ( Str $desc ) {
   # Extract species name from a Greengenes FASTA description, that looks like:
   #    M36507.1 Methanococcus vannielii k__Archaea; [...] ; s__Methanococcus vannielii; otu_144
   # 1/ Remove accession number (first field)
   $desc = (split /\s+/, $desc, 2)[-1] || ''; # \s+ matches one or multiple tab or spaces as delimiter
   # 2/ Remove taxonomy string (starts with k__)
   $desc =~ s/k__.*$//i;
   $desc =~ s/\s+$//;
   return $desc;
}


func extract_img_id ( Str $header ) {
   # Given a FASTA ID, extract the IMG genome ID. In addition to standard FASTA 
   # ID, the ID can be more specific and include an IMG genome ID, an underscore
   # and an IMG gene ID, e.g.: >640753060_640862969
   $header =~ s/_.*$//gi;
   return $header;
}


func gg_id_by_taxa ($gg_db, $search_desc, $search_names) {
   # Parse all Greengenes genome names and sort them by taxa.

   my $named_isolates;
   if ($search_names) {
      # Names are not in FASTA headers, but in separate file. Read them now.
      $named_isolates = read_named_isolates($search_names);
   }

   my $gg_taxa;
   my $stream = $gg_db->get_PrimarySeq_stream;
   while (my $gg_seq = $stream->next_seq) {
      my $gg_id = $gg_seq->id;
      my $gg_scientific;
      if ($search_desc) {
         $gg_scientific = extract_gg_name($gg_seq->desc || '');
      } elsif ($search_names) {
         $gg_scientific = $named_isolates->{$gg_id} || '';
      }
      my ($gg_candidatus, $gg_genus, $gg_species, $gg_strain) = parse_name($gg_scientific);
      next if not $gg_genus; # Organisms without genus are useless for us
      my $gg_strain_clean = massage_strain( $gg_strain );
      $gg_taxa->{$gg_genus}->{$gg_species}->{$gg_strain}->{$gg_id} = [$gg_scientific, $gg_strain_clean];
   }
   return $gg_taxa;
}


func match_names ( $names, $correlations, $missing, $gg_genera ) {
   # Find matching names
   my $num_matches = 0;
   while ( (my $img_id, undef) = each %$missing ) {
      my $img_name = $names->{$img_id};
      next if not defined $img_name;
      #warn "\n";
      warn sprintf( "Info: Searching for name match for IMG ID %12s ... %s\n", $img_id, $img_name);
      my ($gg_id, $gg_name) = match_name($img_name, $gg_genera);
      if ($gg_id) {
         # Found a matching GG ID
         delete $missing->{$img_id};
         $correlations->{$img_id} = $gg_id;
         $num_matches++;
      }
   }
   warn "Info: Found name match for $num_matches IMG IDs ".($num_matches > 0 ? ':D' : ':(((')."\n";
   return $correlations, $missing;
}


func read_named_isolates ($file) {
   # Read a file of named isolates (a SQLite dump) that looks like this:
   #   gg_id|organism|strain
   #   3|Methanocaldococcus jannaschii|
   #   16|Methanocaldococcus fervens AG86|AG86; DSM4213
   my %named_isolates;
   open my $in, '<', $file or die "Error: Could not read file $file\n$!\n";
   my $headers = <$in>;
   while (my $line = <$in>) {
      chomp $line;
      my ($gg_id, $organism, $strain) = split /\|/, $line;
      # Strain cleanup
      $strain =~ s/(type )?strain//g;
      # Merge species and strain to get a full name
      my $full_name;
      my $re = quotemeta($strain);
      if ($organism =~ m/$re/i) {
         $full_name = $organism;
      } else {
         $full_name = $organism.' '.$strain;
      }
      # Record full name
      $named_isolates{$gg_id} = $full_name;
   }
   close $in;
   return \%named_isolates;
}


func write_correspondances ($correlations) {
   while ( my ($img_id, $gg_id) = each %$correlations ) {
      print "$img_id\t$gg_id\n";
   }
   return 1;
}


func read_metadata ( Str $file, $correlations, $missing ) {
   # Read IMG metadata file
   my %metadata;
   open my $fh, '<', $file or die "Error: Could not read file $file\n$!\n";
   my $header = <$fh>;
   chomp $header;
   my ($idcol, $domcol, $namecol) = find_column_for($header, 'taxon_oid', 'Domain', 'Genome Name');
   my $num = 0;
   while (my $line = <$fh>) {
      chomp $line;
      next if $line =~ m/^#/;
      $num++;
      my @splitline = split /\t/, $line;
      my $img_id = $splitline[$idcol];
      my $domain = $splitline[$domcol];
      if ( $domain !~ m/^(?:bacteria|archaea)$/i ) {
         # Keep only bacteria and archaea. Skip eukaryotes, etc.
         delete $correlations->{$img_id};
         delete $missing->{$img_id};
         next;
      }
      my $img_name = $splitline[$namecol];
      $metadata{$img_id} = $img_name;
      if (not exists $correlations->{$img_id}) {
         $missing->{$img_id} = $img_name;
      }
   }
   close $fh;
   warn "Info: Read $num entries from metadata file $file.\n";
   return \%metadata, $correlations, $missing;
}


func read_correspondances ( Str $file ) {
   # Create IMG-GG correlation hash. Get IMG IDs that do not have a
   # corresponding GG ID.
   my %correlations;
   my %missing;
   open my $fh, '<', $file or die "Error: Could not read file $file\n$!\n";
   while (my $line = <$fh>) {
      chomp $line;
      next if $line =~ m/^#/;
      my ($img_id, $gg_id) = split /\t/, $line;
      $correlations{$img_id} = $gg_id;
      if ( (not defined $gg_id) || ($gg_id =~ m/^\s*$/) ) {
         $missing{$img_id} = undef;
      }
   }
   close $fh;
   warn "Info: Read ".scalar(keys(%correlations))." entries from file $file.\n";
   return \%correlations, \%missing;
}


sub find_column_for {
   my ($header_line, @names) = @_;
   # Given a tab-separated header line, find which column matches the given name.
   # Search is insensitive to case, spaces, underscores and dashes. Also, note
   # that matches only need to be partial.
   my @fields = split /\t/, $header_line;
   # Make names and cols insensitive
   for my $arr ( \@fields, \@names ) {
      for my $i (0 .. scalar @$arr - 1) {
         $arr->[$i] =~ s/[\s_-]//g;
         $arr->[$i] = lc $arr->[$i];
      }
   }
   # Look for names in column headers
   my @col_nums;
   for my $name (@names) {
      my $col_num;
      for ($col_num = 0; $col_num < scalar @fields; $col_num++) {
         my $field = $fields[$col_num];
         if ($field =~ m/$name/) {
            push @col_nums, $col_num;
            last;
         }
      }
      if (not defined $col_num) {
         die "Error: Could not find column holding '$name' data\n";
      }
   }
   return @col_nums;
}
