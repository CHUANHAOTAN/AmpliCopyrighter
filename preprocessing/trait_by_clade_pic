#!/usr/bin/env perl

# trait_by_clade_pic
# Copyright 2012 Florent Angly
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade_pic - Summarize a trait at different taxonomic levels using
phylogenetic independent contrasts

=head1 SYNOPSIS

  trait_by_clade_pic -f trait.txt -p gg.tree -t gg_taxo.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and estimates the trait value
at different taxonomic levels using the phylogenetic independent contrasts
method: Felsenstein, "Phylogenies and the comparative method" (1985)

=head1 REQUIRED ARGUMENTS

=over

=item -i <input_file>

Input file of tab-delimited traits. This file should have been generated by the
script data_combiner. This script will use the column called 'GG ID' and the
one specified by the option <trait_name>.

=for Euclid:
   input_file.type: readable

=item -p <phylo_tree>

Input Greengenes phylogenetic tree in Newick format.

=for Euclid:
   phylo_tree.type: readable

=item -t <taxo_file>

Input Greengenes taxonomy file.

=for Euclid:
   taxo_file.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -n <trait_name>

If the input file contains several traits, select the name of the trait to use
(case-insensitive), e.g. '16S rRNA Count' or 'Genome Size'. Make sure this
matches the name of the trait as found in the input file. Default: trait_name.default

=for Euclid:
   trait_name.type: string
   trait_name.default: '16S rRNA Count'

=back

=head1 AUTHOR

Florent Angly <florent.angly@gmail.com>

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Florent Angly

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use Method::Signatures;
use Getopt::Euclid qw(:minimal_keys);
use Statistics::Basic qw(mean);
use Bio::Phylo::IO;
use FindBin qw($Bin);
use lib "$Bin";
use PreprocUtils;

trait_by_clade_pic( $ARGV{'i'}, $ARGV{'p'}, $ARGV{'t'}, $ARGV{'n'} );
exit;

func trait_by_clade_pic ( $input_file, $phylo_tree, $taxo_file, $trait_name ) {

   # Read IMG metadata and extract gg IDs and the desired trait value
   my $id2trait = read_metadata($input_file, $trait_name);

   # Make average for GG IDs that have several trait values (several genomes)
   $id2trait = average_by_key($id2trait);

   # Our very own, special GG tree
   my $tree = grow_tree($phylo_tree, [keys %$id2trait], $id2trait);

   # Calculate interior node trait value using PIC
   $id2trait = pic($tree, $id2trait);

   # Read GG taxonomy and convert GG IDs to GG taxonomy string
   my $gg_taxonomy = PreprocUtils::read_lookup($taxo_file);
   my $tax2trait = convert_id_to_tax($id2trait, $gg_taxonomy);

   # Do average for each taxonomy string
   ###$tax2trait = average_by_key($tax2trait);

   # Print results
   print_results($tax2trait, $trait_name);

   return 1;
}


func print_results ($tax2trait, $trait_name) {
   # Print results, sorted by taxonomic level and alphabetically within each level
   # Sort results by taxonomic level
   my $max_level = 0;
   for my $tax (keys %$tax2trait) {
      my $level = scalar( split /;\s*/, $tax );
      if ($level > $max_level) {
         $max_level = $level;
      }
      $tax2trait->{$level}->{$tax} = $tax2trait->{$tax};
      delete $tax2trait->{$tax};
   }
   # Print results
   print "# taxonomy\t$trait_name\n";
   for my $level (1 .. $max_level) {
      my $entries = $tax2trait->{$level};
      for my $tax ( sort keys %$entries ) {
         my $val = $entries->{$tax};
         print "$tax\t$val\n";
      }
      print "\n";
   }
   return 1;
}


func convert_id_to_tax ($id_hash, $gg_taxonomy) {
   my $tax_hash;
   while ( my ($id, $val) = each %$id_hash ) {
      my $tax = $gg_taxonomy->{$id};
      if (not defined $tax) {
         warn "Warn: Missing GG taxonomy for GG ID $id\n";
         next;
      }
      if (exists $tax_hash->{$tax}) {
         die "Error: There are duplicate taxonomic strings... Need to average\n";
      }
      $tax_hash->{$tax} = $val;
   }
   return $tax_hash;
}


func pic ($tree, $id2trait) {
   # Use phylogenetic independent contrasts method to estimate trait value for
   # interior nodes of given $tree and save this in $id2trait
   # Note: We're irremediably altering the given tree!
   
   warn "Info: Applying phylogenetic independent contrasts to tree\n";
   my $nonzero_length = 1e-5;

   warn "TREE: ".$tree->as_string."\n"; ###

   while ($tree->calc_number_of_cherries > 0) {
      my $cherries = get_cherries($tree);
      while (my ($pid, $nodes) = each %$cherries) {
         # Calculate trait value for parent $pval as a weighted average of the
         # children's trait value @cvals where the weights $weis are proportional
         # to the inverse of the branch distance @dists between parent and
         # children. Hence, the trait value of a child closer to the parent
         # contributes more than the trait value of a childr that is farther away.
         my ($parent, @children) = @$nodes;
         my @cvals  = map { $_->get_generic('trait') } @children;
         my @cdists = map { 0+$_->get_branch_length || $nonzero_length } @children;
         my @weis   = map { 1 / $_ } @cdists;
         my $pval = ($cvals[0]*$weis[0] + $cvals[1]*$weis[1]) / ($weis[0]+$weis[1]);

         warn "CHILDREN: ".$children[0]->get_name."=".$cvals[0]."  ".$children[1]->get_name."=".$cvals[1]."\n"; ###
         warn "PARENT: ".$pid."=".$pval."\n\n"; ###

         # Save parent's trait value
         if (exists $id2trait->{$pid}) {
            ####
            if ($id2trait->{$pid} == $pval) {
               warn "Warn: Parent already has a trait value (".$id2trait->{$pid}."), ".
                    "but with the same value, so that's ok. May need to skip deleting children ".
                    "and stretching parent branch though.\n";
            } else {
               die "Error: Parent already has a trait value (".$id2trait->{$pid}.
                   ") that is different from the value that I want to set ($pval)\n";
            }
            ####
         } else {
            $id2trait->{$pid} = $pval;
         }
         # Delete children
         $parent->prune_child($children[0]);
         $parent->prune_child($children[1]);
         
         # Stretch parent's branch
         my $pdist = $parent->get_branch_length;
         if ( ($cdists[0] > 0) && ($cdists[1] > 0) ) {
            $pdist += $cdists[0]*$cdists[1] / ($cdists[0]+$cdists[1]);
         }
         $parent->set_branch_length($pdist);
      }
   }

   my $nof_nodes = $tree->calc_number_of_nodes;

   if ($nof_nodes == 1) {
      # Print trait value for remaining node
      my $last_node = @{$tree->get_entities}[0];
      my $last_val  = $last_node->get_generic('trait');
      warn "Info: Last tree node (GG ID $last_node) has trait value $last_val\n";
   } else {
      # Error
      my $out_file = 'tree_debug.nw';
      open my $out, '>', $out_file or die "Error: Could not write file $out_file\n$!\n";
      print $out unparse( -phylo => $tree, -format => 'newick' );
      close $out;
      die "Error: Internal problem. There should be only one node left but there ".
          "are still $nof_nodes. Wrote what's left of the tree in the Newick ".
          "file $out_file for debugging\n";
   }

   return $id2trait;
}


func get_cherries ($tree) {
   # Find the cherries in the tree and report them in a hash, keyed by the ID of
   # their parent
   my %cherries;
   for my $tip ( @{ $tree->get_terminals } ) {
      if ( my $parent = $tip->get_parent ) {
         if ( $parent->is_preterminal ) {
            my $children = $parent->get_children;
            if ( scalar @{$children} == 2 ) {
               $cherries{ $parent->get_name } = [$parent, @$children];
            }
         }
      }
   }
   return \%cherries;
}


func grow_tree ($tree_file, $ids, $id2trait) {
   # Parse Newick tree, prune it and attach trait

   # Parse Newick tree
   warn "Info: Parsing and pruning tree $tree_file ...\n";
   my $tree = Bio::Phylo::IO->parse(
      -file   => $tree_file,
      -format => 'newick',
      -keep   => $ids, # remove some of the nodes we won't need
   )->first;
   warn "Info: Saw ".$tree->calc_number_of_terminals()." tree leaves\n";

   # Actual tree pruning
   $tree->keep_tips($ids);
   my $num_leaves = $tree->calc_number_of_terminals;
   warn "Info: $num_leaves tree leaves left\n";

   my $num_ids = scalar keys $ids;
   if ( $num_ids != $num_leaves ) {
      warn "Warn: Looks like the tree is missing ".($num_ids-$num_leaves)." GG IDs\n";
   }

   # Write pruned tree
   ###print unparse( -file => 'pruned_tree.nw', -phylo  => $tree, -format => 'newick' );

   # Attach trait to nodes
   for my $leaf ( @{$tree->get_terminals} ) {
      my $gg_id = $leaf->get_name;
      my $trait_val = $id2trait->{$gg_id} ||
         die "Error: Could not find trait value for tree leaf with GG ID $gg_id\n";
      warn "Info: Setting trait value of GG ID $gg_id (internal ID ".$leaf->get_id." to $trait_val\n"; #####
      $leaf->set_generic( 'trait' => $trait_val );
   }

   return $tree;
}


func read_metadata ( $file, $trait_name ) {
   my %id2trait;
   open my $fh, '<', $file or die "Error: Could not read file $file\n$!\n";
   my $header = <$fh>;
   chomp $header;
   my @cols = PreprocUtils::find_column_for($header, 'GG ID', $trait_name);
   warn "Info: Found trait '$trait_name' in column ".($cols[-1]+1)." of input ".
        "file $file\n";
   # Parse input file
   my $num = 0;
   while (my $line = <$fh>) {
      chomp $line;
      my ($gg_id, $trait_val) = (split /\t/, $line)[@cols];
      if ( (not defined $gg_id) || ($gg_id eq '-') ) {
         next;
      }
      if ( (not defined $trait_val) || ($trait_val eq '-') ) {
         next;
      }
      push @{$id2trait{$gg_id}}, $trait_val;
      $num++;
   }
   close $fh;
   warn "Info: Read $num entries with a GG ID and a trait value\n";
   return \%id2trait;
}


func average_by_key ( $hash ) {
   for my $key (keys %$hash) {
      $hash->{$key} = mean($hash->{$key})->query;
   }
   return $hash;
}
