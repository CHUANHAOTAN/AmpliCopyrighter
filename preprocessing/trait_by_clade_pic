#!/usr/bin/env perl

# trait_by_clade_pic
# Copyright 2012 Florent Angly
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade_pic - Summarize a trait at different taxonomic levels using
phylogenetic independent contrasts

=head1 SYNOPSIS

  trait_by_clade_pic -f trait.txt -p gg.tree -t gg_taxo.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and estimates the trait value
using the phylogenetic independent contrasts method: Felsenstein, "Phylogenies
and the comparative method" (1985). Given a taxonomy, theses trait values are
mapped at all taxonomic levels.

=head1 REQUIRED ARGUMENTS

=over

=item -i <input_file>

Input file of tab-delimited traits. This file should have been generated by the
script data_combiner. This script will use the column called 'GG ID' and the
one specified by the option <trait_name>.

=for Euclid:
   input_file.type: readable

=item -p <phylo_tree>

Input Greengenes phylogenetic tree in Newick format. Note that tree leaf names
should be a Greengenes ID and that internal node names should be annotated
with Greengenes taxonomic information, e.g. 'g__Sphingomonas', where appropriate.

=for Euclid:
   phylo_tree.type: readable

=item -t <taxo_file>

Input Greengenes taxonomy file.

=for Euclid:
   taxo_file.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -c <clip_tree>

Save the pruned tree in the given filename. Also, if the file already exists,
re-use it to skip the pruning step. Default: clip_tree.default

=for Euclid:
   clip_tree.type: writable
   clip_tree.default: 'pruned_tree.nw'

=item -n <trait_name>

If the input file contains several traits, select the name of the trait to use
(case-insensitive), e.g. '16S rRNA Count' or 'Genome Size'. Make sure this
matches the name of the trait as found in the input file. Default: trait_name.default

=for Euclid:
   trait_name.type: string
   trait_name.default: '16S rRNA Count'

=item -a <avg_outliers>

Remove trait values inconsistent with the trait average for this IMG ID: 1=yes,
0=no. Default: avg_outliers.default

=for Euclid:
   avg_outliers.type: integer, avg_outliers == 0 || avg_outliers == 1
   avg_outliers.default: 1

=back

=head1 AUTHOR

Florent Angly <florent.angly@gmail.com>

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Florent Angly

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use Method::Signatures;
use Statistics::Basic qw(mean);
use Getopt::Euclid qw(:minimal_keys);
use Data::Dump qw(dump);
use Bio::Phylo::IO;
use Bio::Phylo::Treedrawer;
use Bio::Community::TaxonomyUtils;
use FindBin qw($Bin);
use lib "$Bin";
use PreprocUtils;

use constant NONZERO => 1e-5;
use constant DEBUG   => 0;

my $gg_taxonomy;
trait_by_clade_pic( $ARGV{'i'}, $ARGV{'p'}, $ARGV{'t'}, $ARGV{'c'}, $ARGV{'n'}, $ARGV{'a'} );
exit;


func trait_by_clade_pic ( $input_file, $phylo_tree, $taxo_file, $clip_tree, $trait_name, $avg_outliers ) {

   # Read IMG metadata and extract gg IDs and the desired trait value
   # Do not average trait for IMG ID with several traits: because of the
   # clustering at 99%, assume that they come from different genomes
   my ($tax2trait, $tax2num) = read_metadata($input_file, $trait_name);

   if ($avg_outliers) {
      ($tax2trait, $tax2num) = remove_outliers($tax2trait, $tax2num);
   }

   # Our very own, special, trimmed GG tree
   my $tree = grow_tree($phylo_tree, $clip_tree, [keys %$tax2trait], $tax2trait, $tax2num);

   # Read GG taxonomy, convert GG IDs to GG taxonomic string
   ($tax2trait, $tax2num) = convert_id_to_tax($tax2trait, $tax2num, $taxo_file, $tree);

   # Calculate interior node trait value using PIC
   ($tax2trait, $tax2num) = pic($tree, $tax2trait, $tax2num);
   ($tax2trait, $tax2num) = PreprocUtils::average_by_key($tax2trait, $tax2num);

   ### 1/ trait for Clostridia larger than that for its children
   ### 2/ have a save_trait() function: can be used in two places

   # Print results
   print_results($tax2trait, $tax2num, $trait_name);

   return 1;
}


func remove_outliers ($tax2trait, $tax2num) {
   my $num_inconsistent = 0;
   my $num_fixed = 0;
   for my $id (keys %$tax2trait) {
      my $vals = $tax2trait->{$id};
      if (scalar @$vals > 1) {
         my $mean = mean($vals)->query;
         my $inconsistent = 0;
         my $fixed = 0;
         my $msg = "Warn: Outlier detected: $id => [".join(', ',@$vals)."].";
         for (my $i = 0; $i <= scalar @$vals - 1; $i++) {
            my $val = $vals->[$i];
            if (not PreprocUtils::near_avg_ssu($val, $mean)) {
               $inconsistent = 1;
               $num_inconsistent++;
               if ($val == 1) {
                  # Remove an outlier (1s seem to be frequent errors)
                  splice @$vals, $i, 1;
                  $i--;
                  $fixed = 1;
                  $num_fixed++;
               }
            }
         }
         if ($fixed) {
            $msg .= " Corrected to [".join(', ',@$vals)."].";
            $tax2trait->{$id} = $vals;
            $tax2num->{$id} = [ (1) x scalar(@$vals) ];
         } else {
            $msg .= " Uncorrected.";
         }
         if ($inconsistent) {
            warn "$msg\n";
         }
      }
   }
   warn "Warn: Found $num_inconsistent inconsistent trait values and corrected $num_fixed of those.\n";
   return $tax2trait, $tax2num;
}


func read_gg_id2taxo ($file) {
   my $id2taxo = PreprocUtils::read_lookup($file);
   for my $id (keys %$id2taxo) {
      my $taxo = $id2taxo->{$id};
      # Parse and clean lineage
      my $lineage_arr = Bio::Community::TaxonomyUtils::split_lineage_string($taxo);
      $taxo = Bio::Community::TaxonomyUtils::get_lineage_string($lineage_arr, 'space');
      $id2taxo->{$id} = $taxo;
   }
   return $id2taxo;
}


func print_results ($tax2trait, $tax2num, $trait_name) {
   # Print results, sorted by taxonomic level and alphabetically within each level
   # Sort results by taxonomic level
   my $max_level = 0;
   for my $tax_str (keys %$tax2trait) {
      # Split and clean taxonomy string to find taxonomic level
      my $lineage_arr = Bio::Community::TaxonomyUtils::split_lineage_string( $tax_str );
      my $level = scalar @$lineage_arr;
      if ($level > $max_level) {
         $max_level = $level;
      }
      # Re-assemble (cleaned) taxonomy string
      my $clean_tax_str = Bio::Community::TaxonomyUtils::get_lineage_string($lineage_arr, 'space');
      $tax2trait->{$level}->{$clean_tax_str} = $tax2trait->{$tax_str};
      delete $tax2trait->{$tax_str};
   }
   # Print results
   print "# taxonomy\t$trait_name\tnum_genomes\n";
   for my $level (1 .. $max_level) {
      my $entries = $tax2trait->{$level};
      for my $tax ( sort keys %$entries ) {
         my $val = sprintf('%.5f', $entries->{$tax});
         my $num = $tax2num->{$tax};
         print "$tax\t$val\t$num\n";
      }
      print "\n";
   }
   return 1;
}


func convert_id_to_tax ($tax2trait, $tax2num, $taxo_file, $tree) {
   warn "Info: Converting GG IDs to taxonomic strings\n";
   my $gg_taxonomy = read_gg_id2taxo($taxo_file);
   my $num_missing = 0;
   for my $id (keys %$tax2trait) {

      # Convert ID to taxonomic string and save array of trait values
      my $tax = $gg_taxonomy->{$id};
      if (not defined $tax) {
         $num_missing++;
         warn "Warn: Missing GG taxonomy for GG ID '$id'\n";
         next;
      }
      my $vals = $tax2trait->{$id};
      push @{$tax2trait->{$tax}}, @$vals;
      push @{$tax2num->{$tax}}, (1) x scalar(@$vals);
      delete $tax2num->{$id};
      delete $tax2trait->{$id};
      warn "Added to $tax: ".dump($vals)."\n" if DEBUG;

      # If the first, named ancestor of this clade is not directly 1 taxonomic
      # level above this one, need to record the intermediary taxonomic levels
      my $node = $tree->get_by_name($id);
      # Get first named ancestor
      my $pid;
      my $ancestor = $node;
      while (1) {
         $ancestor = $ancestor->get_parent;
         $pid = get_clean_name($ancestor); # GG ID or full taxonomic string
         last if not $pid eq '';
      }
      # Process intermediary taxonomic levels
      if (not $tax eq $pid) {
         my $anc_levels = scalar @{Bio::Community::TaxonomyUtils::split_lineage_string($pid)};
         my $lineage = Bio::Community::TaxonomyUtils::split_lineage_string($tax);
         for (my $level = scalar @$lineage - 1; $level >= $anc_levels+1; $level--) {
            my @int_lineage = @{$lineage}[0..$level-1];
            my $int_tax = Bio::Community::TaxonomyUtils::get_lineage_string(\@int_lineage, 'space');
            push @{$tax2trait->{$int_tax}}, @$vals;
            push @{$tax2num->{$int_tax}}, (1) x scalar(@$vals);
            warn "Added to $int_tax: ".dump($vals)."\n" if DEBUG;
         }
      }
   }
   if ($num_missing > 0) {
      warn "Warn: Failed to convert $num_missing IDs to taxonomy\n";
   }

   return $tax2trait, $tax2num;
}


func pic ($tree, $tax2trait, $tax2num) {
   # Use phylogenetic independent contrasts method to estimate trait value for
   # interior nodes of given $tree and save this in $tax2trait
   # Note: We're irremediably altering the given tree!
   
   warn "Info: Applying phylogenetic independent contrasts to tree\n";

   my $round_num = 0;
   while (1) {

      # Get and count apples and cherries
      $round_num++;
      warn "Info: round $round_num\n";
      my $cherries     = get_cherries($tree);
      my $num_cherries = number_of_cherries($cherries);
      my $apples       = get_apples($tree);
      my $num_apples   = number_of_apples($apples);
      my $num_fruits = $num_cherries + $num_apples;
      last if $num_fruits <= 0;

      # Process and remove cherries
      warn "Info: processing $num_cherries cherries\n";
      while (my ($uid, $nodes) = each %$cherries) {
         my ($parent, @children) = @$nodes;
         ($tax2trait, $tax2num) = process_fruit_by_pic($parent, \@children, $tax2trait, $tax2num);
      }

      # Process and remove apples
      warn "Info: processing $num_apples apples\n";
      while (my ($uid, $nodes) = each %$apples) {
         my ($parent, @children) = @$nodes;
         ($tax2trait, $tax2num) = process_fruit_by_pic($parent, \@children, $tax2trait, $tax2num);
      }

   }

   # Wrap up and hope for a happy ending (single leaf remaining)
   my $nof_leaves  = $tree->calc_number_of_terminals;
   my $nof_interns = $tree->calc_number_of_internals;
   if ( ($nof_leaves == 1) && ($nof_interns == 0) ) {
      # Print trait value for remaining node
      my $last_node = @{$tree->get_entities}[0];
      my $last_val  = $last_node->get_generic('trait');
      my $last_num  = $last_node->get_generic('num'  );
      warn "Info: No internal nodes remaining. The last tree leaf had trait ".
         "value $last_val (based on $last_num genomes)\n";
   } else {
      # Error
      my $out_file = 'tree_debug.nw';
      PreprocUtils::write_tree($tree, $out_file);
      die "Error: Internal problem. There should be only one leaf left and no ".
          "internal nodes but there are still $nof_leaves leaves and $nof_interns ".
          "internal nodes. Wrote what's left of the tree in the Newick file ".
          "$out_file for debugging\n";
   }

   return $tax2trait, $tax2num;
}


func process_fruit_by_pic ($parent, $children, $tax2trait, $tax2num) {
   # Calculate trait value for parent $pval as a weighted average of the
   # children's trait value @cvals where the weights $weis are proportional
   # to the inverse of the branch distance @dists between parent and
   # children. Hence, the trait value of a child closer to the parent
   # contributes more than the trait value of a childr that is farther away.

   # Note: This function works with a single child or two children

   my $pval;
   my $pdist = $parent->get_branch_length;
   my @cvals  = map { $_->get_generic('trait')           } @$children;
   my @cdists = map { 0+$_->get_branch_length || NONZERO } @$children;
   if (scalar @cvals == 2) {
      # Calculate trait value for parent
      my @weis   = map { 1 / $_ } @cdists;
      $pval = ($cvals[0]*$weis[0] + $cvals[1]*$weis[1]) / ($weis[0]+$weis[1]);
      # Stretch parent's branch
      if ( ($cdists[0] > 0) && ($cdists[1] > 0) ) {
         $pdist += $cdists[0]*$cdists[1] / ($cdists[0]+$cdists[1]);
      }
      $parent->set_branch_length($pdist);
   } else {
      $pval   = $cvals[0];
      $pdist += $cdists[0];
   }
   $parent->set_generic('trait' => $pval);

   my $pnum = 0;
   for my $child (@$children) {
      my $num = $child->get_generic('num');
      $pnum += $num;
   }
   $parent->set_generic('num' => $pnum);

   print_nodes($parent, @$children) if DEBUG;

   # Delete children
   for my $child (@$children) {
      $parent->prune_child($child);
   }

   # Skip anonymous internal nodes
   my $tax = get_clean_name($parent); # GG ID or full taxonomic string
   if (not $tax eq '') {
      # Save parent's trait value

      ####$tax2trait = save_trait($tax, $tax2trait);

      # Due to the imperfection of matching a taxonomy on a tree, the
      # taxonomy name can be on several nodes of the tree. Save all trait
      # values to make an average in these cases. We'll need to average later,
      # but not before all IDs have been converted to taxonomic strings (we
      # don't want to do averages of averages).
      push @{$tax2trait->{$tax}}, $pval;
      push @{$tax2num->{$tax}}, $pnum;
      warn "Added to $tax: ".dump([$pval])."\n" if DEBUG;

      # If GG label name $tax contains several taxonomic levels e.g.
      # 'o__Rhizobiales; f__Rhodobiaceae', record them all.
      my $num_levels = scalar (split /\.,/, $parent->get_name);
      if ($num_levels > 1) {
         my $lineage = Bio::Community::TaxonomyUtils::split_lineage_string($tax);
         my $max_idx = scalar @$lineage - 1;
         for my $level (1 .. $num_levels-1) {
            my @arr = @{$lineage}[0..$max_idx-$level];
            my $name = Bio::Community::TaxonomyUtils::get_lineage_string(\@arr, 'space');
            push @{$tax2trait->{$name}}, $pval;
            push @{$tax2num->{$name}}, $pnum;
            warn "Added to $name: ".dump([$pval])."\n" if DEBUG;
         }
      }
   }
   return $tax2trait, $tax2num;
}


func get_apples (Bio::Phylo::Forest::Tree $tree) {
   # Find apples in the tree and report them in a hash, keyed by the parent ID
   return get_fruits($tree, 1);
}


func number_of_apples ($apples) {
   return scalar keys %$apples;
}


func get_cherries (Bio::Phylo::Forest::Tree $tree) {
   # Find cherries in the tree and report them in a hash, keyed by the parent ID
   return get_fruits($tree, 2);
}


func number_of_cherries ($cherries) {
   return 2 * (scalar keys %$cherries);
}


func get_fruits (Bio::Phylo::Forest::Tree $tree, Int $num_children) {
   # Find apples in the tree and report them in a hash, keyed by the parent ID
   my %fruits;
   for my $tip ( @{ $tree->get_terminals } ) {
      if ( my $parent = $tip->get_parent ) {
         if ( $parent->is_preterminal ) {
            my $children = $parent->get_children;
            my $pid = $parent->get_id;
            if ( (scalar @{$children} == $num_children) && (not exists $fruits{$pid}) ) {
               $fruits{$pid} = [$parent, @$children];
            }
         }
      }
   }
   return \%fruits;
}


func print_nodes ($parent, $child1?, $child2?) {
   # Print node info for parent and optional two children
   my $msg;
   if ($child1) {
      $msg .= "CHILD1: '".(get_clean_name($child1)||'?')."' (uid ".$child1->get_id.") = ".$child1->get_generic('trait')."  (".$child1->get_generic('num')." genomes)\n";
   }
   if ($child2) {
      $msg .= "CHILD2: '".(get_clean_name($child2)||'?')."' (uid ".$child2->get_id.") = ".$child2->get_generic('trait')."  (".$child2->get_generic('num')." genomes)\n";
   $msg    .= "PARENT: '".(get_clean_name($parent)||'?')."' (uid ".$parent->get_id.") = ".$parent->get_generic('trait')."  (".$parent->get_generic('num')." genomes)\n";
   }
   warn "$msg\n";
   return 1;
}


func draw_tree ( Bio::Phylo::Forest::Tree $tree, $file) {
   my $treedrawer = Bio::Phylo::Treedrawer->new(
      -width  => 1200,
      -height =>  800,
      -shape  => 'rect',
      -mode   => 'phylo',
      -format => 'svg'
   );
   $treedrawer->set_tree($tree);
   open my $out, '>', $file or die "Error: Could not write file $file\n$!\n";
   print $out $treedrawer->draw;
   close $out;
   return 1;
}


func grow_tree ($tree_file, $clip_file, $gg_ids, $tax2trait, $tax2num) {
   # Parse Newick tree, prune it and attach trait

   # Parse Newick tree
   my $tree;
   my $num_leaves;
   if ((defined $clip_file) && (-f $clip_file)) {
      warn "Info: Parsing already-pruned tree $clip_file ...\n";
      $tree = Bio::Phylo::IO->parse(
         -file   => $clip_file,
         -format => 'newick',
      )->first;
      $tree = rename_anon_nodes($tree);
      $num_leaves = $tree->calc_number_of_terminals();
      warn "Info: Saw $num_leaves tree leaves\n";
   } else {
      warn "Info: Cleaning tree $tree_file ...\n";
      my $tree_string = clean_newick($tree_file);

      print_tree($tree_string, 'debug1.nw') if DEBUG;

      warn "Info: Parsing tree...\n";
      $tree = Bio::Phylo::IO->parse(
         -string => $tree_string,
         -format => 'newick',
         -keep   => $gg_ids, # remove some of the nodes we won't need
      )->first;
      warn "Info: Saw ".$tree->calc_number_of_terminals()." tree leaves\n";

      #print_tree($tree, 'debug2.nw') if DEBUG;
      print_tree_nodes($tree, 'debug2_leaves.txt') if DEBUG;

      warn "Info: Pruning tree...\n";
      $tree = keep_tips_custom($tree, $gg_ids);

      $num_leaves = $tree->calc_number_of_terminals;
      warn "Info: $num_leaves tree leaves left\n";

      #print_tree($tree, 'debug3.nw') if DEBUG;
      print_tree_nodes($tree, 'debug3_leaves.txt') if DEBUG;

      # Write pruned tree if requested
      if ($clip_file) {
         warn "Info: Saving tree to $clip_file ...\n";
         PreprocUtils::write_tree($tree, $clip_file);
      }
   }

   my $num_ids = scalar keys $gg_ids;
   if ( $num_ids != $num_leaves ) {
      warn "Warn: Looks like the tree is missing ".($num_ids-$num_leaves)." GG IDs\n";
   }

   # Attach trait to nodes
   for my $leaf ( @{$tree->get_terminals} ) {
      my $gg_id = get_clean_name($leaf);
      my $vals = $tax2trait->{$gg_id} ||
         die "Error: Could not find trait value for tree leaf with GG ID $gg_id\n";
      my $num = scalar @{$tax2num->{$gg_id}};
      my $val = mean($vals)->query;
      $leaf->set_generic( 'trait' => $val );
      $leaf->set_generic( 'num'   => $num );
   }

   return $tree;
}


func rename_anon_nodes (Bio::Phylo::Forest::Tree $tree) {
   # Remove anonymous nodes (called Node1234 by Bio::Phylo)
   for my $node (@{$tree->get_internals}) {
      if ($node->get_name =~ m/^Node\d+$/i) {
         $node->set_name('');
      }
   }
   return $tree;
}


func keep_tips_custom ($tree, $tip_names) {
   # Essentially the same as Bio::Phylo::Forest::Tree::keep_tips() but do not
   # remove internal tree nodes that are named.
   # get node objects for tips
   my @tips = @{ $tree->_get_tip_objects($tip_names) };
   # identify nodes that are somewhere on the path from tip to root
   my %seen;
   for my $tip ( @tips ) {
      my $node = $tip;
      PARENT: while ( $node ) {
         my $id = $node->get_id;
         if ( not exists $seen{$id} ) {
            $seen{$id} = $node;
            $node = $node->get_parent;
         } else {
            last PARENT;
         }            
      }
   }
   # now do the pruning
   $tree->visit_depth_first(
      '-post' => sub {
         my $n = shift;
         my $p = $n->get_parent;
         if ( not exists $seen{$n->get_id} ) {
            $p->delete($n) if $p;
            $tree->delete($n);
            return;
         }
         if ( $n->get_name eq '' ) {
            # This is an anonymous node
            my @children = @{ $n->get_children };
            if ( scalar @children == 1 ) {
               # Node has a single child
               my ($c) = @children;
               my $bl  = $n->get_branch_length;
               my $cbl = $c->get_branch_length;
               $c->set_branch_length( $bl + $cbl ) if defined $cbl && defined $bl;
               $tree->delete($n);
               $c->set_parent($p);
               $p->delete($n) if $p;
            }
         }
      }
   );
   return $tree;
}


func print_tree_nodes ($tree, $file) {
   # Given a Bio::Phylo::Forest::Tree, write the name of its node in the
   # specified file name.
   open my $out, '>', $file or die "Error: Could not write file $file\n$!\n";
   for my $node (@{$tree->get_entities}) {
      print $out $node->get_id.":  ".(get_clean_name($node)||"''")."\n";
   }
   close $out;
   return 1;
}


func print_tree ($tree, $file) {
   # Given a Bio::Phylo::Forest::Tree, write its Newick representation in the
   # specified file name. Alternatively, you can pass a Newick string directly.
   my $tree_string;
   if ( ref($tree) eq 'Bio::Phylo::Forest::Tree' ) {
      $tree_string = $tree->as_string;
   } else {
      $tree_string = $tree;
   }
   open my $out, '>', $file or die "Error: Could not write file $file\n$!\n";
   print $out $tree_string;
   close $out;
   return 1;
}


func clean_newick ($file) {
   # Take a tree in a Newick file, cleans quoted node names like '100:s__Bacteroides
   # dorei' to 's__Bacteroides dorei', i.e. keep only the taxonomy name. Need to
   # keep the single-quotes because some taxon names contain semicolons.
   # Actually, also convert semicolons to '.,' because it will confuse the -keep
   # option of Bio::Phylo::IO->parse(). Also the -keep option will remove spaces
   # in an inconvenient way, e.g., 'Halorhabdus utahensis' becomes 'Halorhabdusutahensis'

   my $tree_string;
   open my $in, '<', $file or die "Error: Could not read file $file\n$!\n";
   while (my $line = <$in>) {
      # Replace semicolons and whitespaces in node names

      # In gg prior to 2012, also remove bootstrap values from internal node name
      # (they get confused with a GG ID)
      #   (570306:0.00512,574579:0.00227)63:0.00228
      # becomes
      #   (570306:0.00512,574579:0.00227):0.00228
      #$line =~ s/'(.+?:)?(.*?)'/replace_chars("'$2'")/ge;

      # For GG >= 2012
      $line =~ s/'(.*?)'/replace_chars("'$1'")/ge;
      $line =~ s/\)\d+/)/g;
      $tree_string .= $line;
   }
   close $in;
   return $tree_string;
}


func replace_chars ($string) {
   # Replace any semicolon in the given string by '.,' and any space by '\s'
   $string =~ s/;/.,/g;
   $string =~ s/ /\\s/g;
   return $string;
}


func restore_chars ($string) {
   # Restore any '.,' to semicolon and any '\s' to space
   $string =~ s/.,/;/g;
   $string =~ s/\\s/ /g;
   return $string;
}


func get_clean_name ($node) {
   # Get node name, replace semicolons and unquote it. If the name is not an ID
   # but part of a taxonomic string, e.g. 'g__Bacteroides' or 's__Bacteroides salyersiae'
   # reconstruct the full taxonomic string
   my $name = clean_name($node->get_name);
   if ( not is_id($name) ) {
      while (1) {
         $node = $node->get_parent;
         if (not defined $node) {
            last;
         }
         my $parent_name = clean_name($node->get_name);
         if ( not is_id($parent_name) ) {
            $name = $parent_name.'; '.$name;
         }
      }
   }
   if ( not($name eq '') && not(is_id($name)) && not($name =~ m/^k__/) ) {
      warn "Warn: Taxonomic string $name is suspicious; it does not start ".
           "with 'k__'\n";
   }
   return $name;
}


func is_id ($str) {
   # Returns true is given string contains only numerals 0-9
   return( ($str =~ m/[^0-9]/) ? 0 : 1 );
}


func clean_name ($name) {
   $name = restore_chars($name);
   $name =~ s/^'(.*)'$/$1/;
   $name =~ s/^"(.*)"$/$1/;
   return $name;
}


func read_metadata ( $file, $trait_name ) {
   my (%tax2trait, %tax2num);
   open my $fh, '<', $file or die "Error: Could not read file $file\n$!\n";
   my $header = <$fh>;
   chomp $header;
   my @cols = PreprocUtils::find_column_for($header, 'GG ID', $trait_name);
   warn "Info: Found trait '$trait_name' in column ".($cols[-1]+1)." of input ".
        "file $file\n";
   # Parse input file
   my $num = 0;
   while (my $line = <$fh>) {
      chomp $line;
      my ($gg_id, $trait_val) = (split /\t/, $line)[@cols];
      if ( (not defined $gg_id) || ($gg_id eq '-') ) {
         next;
      }
      if ( (not defined $trait_val) || ($trait_val eq '-') ) {
         next;
      }
      push @{$tax2trait{$gg_id}}, $trait_val;
      push @{$tax2num{$gg_id}}, 1;
      $num++;
   }
   close $fh;
   warn "Info: Read $num entries with a GG ID and a trait value\n";
   return \%tax2trait, \%tax2num;
}

