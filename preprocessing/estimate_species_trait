#!/usr/bin/env perl

# estimate_species_trait
# Copyright 2012 Florent Angly
# You may distribute this module under the terms of the GPLv3


=head1 NAME

estimate_species_trait - Estimate the value of a trait for species using
phylogenetic independent contrasts

=head1 SYNOPSIS

  estimate_species_trait -f trait.txt -p gg.tree -t gg_taxo.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and estimates the trait value
for other species using the phylogenetic independent contrasts method with
rerooting: Garland & Ives "Using the Past to Predict the Present" 2000

To do so, it uses the Newick Utils programs and Bio::Phylo Perl modules.

=head1 REQUIRED ARGUMENTS

=over

=item -i <input_file>

Input file of tab-delimited traits. This file should have been generated by the
script data_combiner. This script will use the column called 'GG ID' and the
one specified by the option <trait_name>.

=for Euclid:
   input_file.type: readable

=item -p <phylo_tree>

Input Greengenes phylogenetic tree in Newick format. Note that tree leaf names
should be a Greengenes ID and that internal node names should be annotated
with Greengenes taxonomic information, e.g. 'g__Sphingomonas', where appropriate.

=for Euclid:
   phylo_tree.type: readable

=item -t <taxo_file>

Input Greengenes taxonomy file.

=for Euclid:
   taxo_file.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -n <trait_name>

If the input file contains several traits, select the name of the trait to use
(case-insensitive), e.g. '16S rRNA Count' or 'Genome Size'. Make sure this
matches the name of the trait as found in the input file. Default: trait_name.default

=for Euclid:
   trait_name.type: string
   trait_name.default: '16S rRNA Count'

=item -a <avg_outliers>

Remove trait values inconsistent with the trait average for this IMG ID: 1=yes,
0=no. Default: avg_outliers.default

=for Euclid:
   avg_outliers.type: integer, avg_outliers == 0 || avg_outliers == 1
   avg_outliers.default: 1

=item -c <num_cpus>

Specify the number of processes to use. This is script is slow, so you better
use many processes. Default: num_cpus.default

=for Euclid:
   num_cpus.type: integer, num_cpus > 0
   num_cpus.default: 1

=back

=head1 AUTHOR

Florent Angly <florent.angly@gmail.com>

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Florent Angly

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use threads;
use Thread::Queue;
use Method::Signatures;
use Statistics::Basic qw(mean);
use Getopt::Euclid qw(:minimal_keys);
use Data::Dump qw(dump);
use IPC::Run qw(run);
use Bio::Phylo::IO;
use Bio::Community::TaxonomyUtils;
use FindBin qw($Bin);
use lib "$Bin";
use PreprocUtils;

use constant NONZERO => 1e-5;
use constant DEBUG   => 0;

my $gg_taxonomy;
estimate_species_trait( $ARGV{'i'}, $ARGV{'p'}, $ARGV{'t'}, $ARGV{'n'},
   $ARGV{'a'}, $ARGV{'c'} );
exit;

######
# what to do for taxonomies that have both experimental and estimated trait?
#    surely the experimental trait should have precedence. Ignore the estimated trait altogether?
######


func estimate_species_trait ( $input_file, $phylo_tree, $taxo_file, $trait_name, $avg_outliers, $num_cpus ) {
   my $tax2trait = read_metadata($input_file, $trait_name);
   if ($avg_outliers) {
      $tax2trait = remove_outliers($tax2trait);
   }
   $tax2trait = estimate_trait($phylo_tree, $tax2trait, $num_cpus);
   $tax2trait = map_tree_to_taxo($tax2trait, $taxo_file);
   $tax2trait = PreprocUtils::average_by_key($tax2trait);
   print_results($tax2trait, $trait_name);
   return 1;
}


func map_tree_to_taxo ($tax2trait, $taxo_file) {
   # Convert leaf ID from GG ID to GG taxo
   my $taxonomy = PreprocUtils::read_lookup($taxo_file);
   for my $id (keys %$tax2trait) {
      my $val    = $tax2trait->{$id};
      my $taxstr = $taxonomy->{$id};
      if (defined $taxstr) {
         push @{$tax2trait->{$taxstr}}, @$val;
         delete $tax2trait->{$id};
      }
   }
   return $tax2trait;
}


func estimate_trait($tree_file, $tax2trait, $num_cpus) {
   # Estimate the trait value for leaves that do not have it
   my @ids_to_keep = keys $tax2trait;
   my $nw_tree = clean_newick($tree_file);

   my $q = Thread::Queue->new();
   for my $id (@{read_leaf_names($nw_tree)}) {
      if (not exists $tax2trait->{$id}) {
         $q->enqueue($id);
      }
   }
   warn "Info: There are ".$q->pending." leaves for which to estimate trait.\n";

   # Copy hash and average trait values
   my $tax2avgtrait = { %$tax2trait };
   $tax2avgtrait = PreprocUtils::average_by_key($tax2avgtrait);

   # Create thread pool
   my @threads;
   for my $i (1 .. $num_cpus) {
      my $thr = threads->create(\&worker, $q, $nw_tree, \@ids_to_keep, $tax2avgtrait);
      if (not defined $thr) {
         die "Error: Could not create thread\n$!\n";
      }
      $q->enqueue(undef);
      push @threads, $thr;
   }

   # Wait for all threads to finish their work
   for my $thr (@threads) {
      my $trait_estimates = $thr->join();
      if (my $err = $thr->error) {
         die "$err\n";
      }

      ####
      warn "trait_estimates thread ".threads->tid().": ".dump($trait_estimates)."\n";
      ####

      # Add estimates to given trait values
      for my $id (keys %$trait_estimates) {
         push @{$tax2trait->{$id}}, delete $trait_estimates->{$id};
      }
   }

   $tax2avgtrait = {};

   ####
   warn "tax2trait: ".dump($tax2trait)."\n";
   ####

   return $tax2trait;
}


func worker ($id_q, $nw_tree, $ids_to_keep, $tax2avgtrait) {
   my $tid = threads->tid();
   open my $out, '>', "tmp_estimate_$tid.txt" or die "Error: Could not write file $!\n";
   my %trait_estimates;

   #my $num = 1; ####

   for my $id (@$id_q) {
      my $tree = grow_tree($nw_tree, $ids_to_keep, $id, $tax2avgtrait);
      my $val = leaf_pic($id, $tree);
      print $out "$id\t$val\n";
      $trait_estimates{$id} = $val;

      #$num++; last if $num > 3; ####

   }
   close $out;
   return \%trait_estimates;
}


func read_leaf_names ($nw_string) {
   # Read leaf names from Newick file, assuming that the tree has branch lengths
   my @leaf_names = ($nw_string =~ m/[(,]([a-z0-9]+?):/gi);
   return \@leaf_names;
}


func leaf_pic ($gg_id, $tree) {
   # Use phylogenetic independent contrasts method to estimate and return the
   # trait value for the given leaf node. Tree should be pruned will be modified
   # IN-PLACE!
   warn "Info: Applying phylogenetic independent contrasts to leaf $gg_id\n";
   while (1) {
      # Get and count cherries
      my $cherries = get_cherries($tree);
      last if not scalar keys %$cherries;
      # Process and remove cherries
      for my $nodes (values %$cherries) {
         my ($parent, @children) = @$nodes;
         $parent = process_by_pic($parent, \@children);
      }
   }

   # Check that only a single leaf remains
   my @leaves = @{$tree->get_terminals};
   my $nof_leaves  = scalar @leaves;
   if (not ($nof_leaves == 1)) {
      my $out_file = 'tree_debug.nw';
      PreprocUtils::write_tree($tree, $out_file);
      die "Error: Internal problem. There should be only one leaf left and no ".
          "internal nodes but there are still $nof_leaves leaves. Wrote what's".
          " left of the tree in the Newick file $out_file for debugging\n";
   }

   my $val = $leaves[0]->get_generic('trait');
   warn "Info: Estimated trait value was $val\n";
   return $val;
}


func remove_outliers ($tax2trait) {
   my $num_inconsistent = 0;
   my $num_fixed = 0;
   for my $id (keys %$tax2trait) {
      my $vals = $tax2trait->{$id};
      if (scalar @$vals > 1) {
         my $mean = mean($vals)->query;
         my $inconsistent = 0;
         my $fixed = 0;
         my $msg = "Warn: Outlier detected: $id => [".join(', ',@$vals)."].";
         for (my $i = 0; $i <= scalar @$vals - 1; $i++) {
            my $val = $vals->[$i];
            if (not PreprocUtils::near_avg_ssu($val, $mean)) {
               $inconsistent = 1;
               $num_inconsistent++;
               if ($val == 1) {
                  # Remove an outlier (1's seem to be frequent errors)
                  splice @$vals, $i, 1;
                  $i--;
                  $fixed = 1;
                  $num_fixed++;
               }
            }
         }
         if ($fixed) {
            $msg .= " Corrected to [".join(', ',@$vals)."].";
            $tax2trait->{$id} = $vals;
         } else {
            $msg .= " Uncorrected.";
         }
         if ($inconsistent) {
            warn "$msg\n";
         }
      }
   }
   warn "Warn: Found $num_inconsistent inconsistent trait values and corrected $num_fixed of those.\n";
   return $tax2trait;
}


func print_results ($tax2trait, $trait_name) {
   # Print results, sorted by taxonomic level and alphabetically within each level
   # Sort results by taxonomic level
   print "# taxonomy\t$trait_name\n";
   for my $tax ( sort keys %$tax2trait ) {
      my $val = sprintf('%.5f', $tax2trait->{$tax});
      print "$tax\t$val\n";
   }
   print "\n";
   return 1;
}


func process_by_pic ($parent, $children) {
   # Calculate trait value for parent $pval as a weighted average of the
   # children's trait value @cvals where the weights $weis are proportional
   # to the inverse of the branch distance @dists between parent and
   # children. Hence, the trait value of a child closer to the parent
   # contributes more than the trait value of a childr that is farther away.

   my @cvals  = map { $_->get_generic('trait')           } @$children;
   my @cdists = map { 0+$_->get_branch_length || NONZERO } @$children;

   # Calculate trait value for parent
   my @weis = map { 1 / $_ } @cdists;
   my $pval = ($cvals[0]*$weis[0] + $cvals[1]*$weis[1]) / ($weis[0]+$weis[1]);
   $parent->set_generic('trait' => $pval);

   # Stretch parent's branch
   my $pdist = $parent->get_branch_length;
   if ( ($cdists[0] > 0) && ($cdists[1] > 0) ) {
      $pdist += $cdists[0]*$cdists[1] / ($cdists[0]+$cdists[1]);
   }
   $parent->set_branch_length($pdist);

   print_nodes($parent, @$children) if DEBUG;

   # Delete children
   for my $child (@$children) {
      $parent->prune_child($child);
   }

   return $parent;
}


func get_cherries (Bio::Phylo::Forest::Tree $tree) {
   # Find cherries in the tree and report them in a hash, keyed by the parent ID
   my %cherries;
   for my $tip ( @{ $tree->get_terminals } ) {
      if ( my $parent = $tip->get_parent ) {
         my $pid = $parent->get_id;
         if (exists $cherries{$pid}) {
            next;
         }
         if ( $parent->is_preterminal ) {
            my $children = $parent->get_children;
            if ( scalar @{$children} == 2 ) {
               $cherries{$pid} = [$parent, @$children];
            }
         }
      }
   }
   return \%cherries;
}


func print_nodes ($parent, $child1?, $child2?) {
   # Print node info for parent and optional two children
   my $msg;
   if ($child1) {
      $msg .= "CHILD1: '".(get_full_name($child1)||'?')."' (uid ".$child1->get_id.") = ".($child1->get_generic('trait')||"")."\n";
   }
   if ($child2) {
      $msg .= "CHILD2: '".(get_full_name($child2)||'?')."' (uid ".$child2->get_id.") = ".($child2->get_generic('trait')||"")."\n";
   }
   $msg    .= "PARENT: '".(get_full_name($parent)||'?')."' (uid ".$parent->get_id.") = ".($parent->get_generic('trait')||"")."\n";
   warn "$msg\n";
   return 1;
}


func grow_tree ($nw_tree, $kept_ids, $root_id, $tax2avgtrait) {
   # Prunt, reroot and attach traits to tree
   $nw_tree = nw_reroot(
                 nw_prune($nw_tree, [$root_id, @$kept_ids]),
                 $root_id,
              );
   my $tree = Bio::Phylo::IO->parse(  ### SEGMENTATION FAULT
      -string => $nw_tree,
      -format => 'newick',
   )->first;
   $tree = attach_trait_to_leaves ($tree, $tax2avgtrait);
   return $tree;
}


func nw_prune ($nw_tree, $labels_to_keep) {
   # Use nw_prune to prune tree in given Newick file
   my $prog = 'nw_prune';
   my $cmd  = [$prog, '-v', '-', @$labels_to_keep];
   my ($in, $out, $err);
   $in = $nw_tree; # feed newick tree to stdin
   run $cmd, \$in, \$out, \$err or die "Error: $prog failed with status $?\n";
   $nw_tree = $out;
   return $nw_tree;
}


sub nw_reroot {
   my ($nw_tree, $root_label) = @_;
   # Run nw_reroot
   my $prog = 'nw_reroot';
   my $cmd  = [$prog, '-l', '-', $root_label];
   my ($in, $out, $err);
   $in = $nw_tree;
   run $cmd, \$in, \$out, \$err or die "Error: $prog failed with status $?\n";
   $nw_tree = $out;
   # Make $root_label the root, not an outgroup, i.e. go from:
   #    (X:0.075,(C:0.140000,(A:0.110000,B:0.120000)Int1:0.29)Int2:0.075) ;
   # to:
   #    (        (C:0.140000,(A:0.110000,B:0.120000)Int1:0.29)Int2:0.150)X;
   $nw_tree =~ s/ ^\($root_label:(\S+?),(.*):(\S+?)\);$ / "($2:".($1+$3).")$root_label;" /ex;
   return $nw_tree;
}


func print_tree_nodes ($tree, $file) {
   # Given a Bio::Phylo::Forest::Tree, write the name of its node in the
   # specified file name.
   open my $out, '>', $file or die "Error: Could not write file $file\n$!\n";
   for my $node (@{$tree->get_entities}) {
      print $out $node->get_id.":  ".(get_full_name($node)||"''")."\n";
   }
   close $out;
   return 1;
}


func clean_newick ($file) {
   # Sanitize some characters and workaround tree re-rooting issue
   my $nw_string;
   open my $in, '<', $file or die "Error: Could not read file $file\n$!\n";
   while (my $line = <$in>) {
      # Replace semicolons and whitespaces in node names
      $line =~ s/'(.*?)'/replace_chars("'$1'")/ge;
      $line =~ s/\)\d+/)/g;
      $nw_string .= $line;
   }
   close $in;
   chomp $nw_string;
   return $nw_string;
}


func replace_chars ($string) {
   # Replace any semicolon in the given string by '.,' and any space by '\s'
   $string =~ s/;/.,/g;
   $string =~ s/ /\\s/g;
   return $string;
}


func restore_chars ($string) {
   # Restore any '.,' to semicolon and any '\s' to space
   $string =~ s/.,/;/g;
   $string =~ s/\\s/ /g;
   return $string;
}


func get_full_name ($node) {
   # Get node name, replace semicolons and unquote it. If the name is not an ID
   # but part of a taxonomic string, e.g. 'g__Bacteroides' or 's__Bacteroides salyersiae'
   # reconstruct the full taxonomic string
   my $name = get_short_name($node);
   if ( not is_id($name) ) {
      while (1) {
         $node = $node->get_parent;
         if (not defined $node) {
            last;
         }
         my $parent_name = clean_name($node->get_name);
         if ( not is_id($parent_name) ) {
            $name = $parent_name.'; '.$name;
         }
      }
   }
   return $name;
}


func get_short_name ($node) {
   return clean_name($node->get_name);
}


func is_id ($str) {
   # Returns true is given string contains only numerals 0-9
   return( ($str =~ m/[^0-9]/) ? 0 : 1 );
}


func clean_name ($name) {
   $name = restore_chars($name);
   $name =~ s/^'(.*)'$/$1/;
   $name =~ s/^"(.*)"$/$1/;
   return $name;
}


func read_metadata ( $file, $trait_name ) {
   my %tax2trait;
   open my $fh, '<', $file or die "Error: Could not read file $file\n$!\n";
   my $header = <$fh>;
   chomp $header;
   my @cols = PreprocUtils::find_column_for($header, 'GG ID', $trait_name);
   warn "Info: Found trait '$trait_name' in column ".($cols[-1]+1)." of input ".
        "file $file\n";
   # Parse input file
   my $num = 0;
   while (my $line = <$fh>) {
      chomp $line;
      next if $line =~ m/^#/;
      my ($gg_id, $trait_val) = (split /\t/, $line)[@cols];
      if ( (not defined $gg_id) || ($gg_id eq '-') ) {
         next;
      }
      if ( (not defined $trait_val) || ($trait_val eq '-') ) {
         next;
      }
      push @{$tax2trait{$gg_id}}, $trait_val;
      $num++;
   }
   close $fh;
   warn "Info: Read $num trait values for ".(scalar keys %tax2trait)." different GG IDs\n";
   return \%tax2trait;
}


func attach_trait_to_leaves ($tree, $trait_avgs) {
   # Attach trait values to leaves of the tree
   for my $leaf (@{$tree->get_terminals}) {
      $leaf->set_generic( 'trait' => $trait_avgs->{$leaf->get_name} );
   }
   return $tree;
}

