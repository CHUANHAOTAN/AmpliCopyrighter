#! /usr/bin/env perl

# trait_by_clade
# Copyright 2012 Adam Skarshewski
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade - Summarize a trait by clade average

=head1 SYNOPSIS

  trait_by_clade -f trait.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and calculates its average at
all taxonomic levels.

=head1 REQUIRED ARGUMENTS

=over

=item -i <input>

Input file of traits. This file should have been generated by the script
data_combiner.

=for Euclid:
   input.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -t <trait>

If the input file contains several trait, select the name of the trait to use
(case-insensitive), e.g. '16S count' or 'genome length'. Make sure this matches
the name of the trait as found in the input file. Default: trait.default

=for Euclid:
   trait.type: string
   trait.default: '16S Count'

=item -a <advanced>

Use advanced output: 1 is yes, 0 is no. The basic output is a tab-delimited file
with two columns: Taxonomy, Mean. The advanced output contains additional
information distributed over four columns: Taxonomy, Num, Mean, Stddev. Default:
advanced.default

=for Euclid:
   advanced.type: integer, advanced == 0 || advanced == 1
   advanced.default: 0

=back

=head1 AUTHOR

Adam Skarshewski

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Adam Skarshewski

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use Getopt::Euclid qw(:minimal_keys);
use Statistics::Basic qw(mean stddev);
$Statistics::Basic::IPRES = 14;


open(my $fh, '<', $ARGV{'i'}) or die "Error: Could not read file ".$ARGV{'i'}."\n$!\n";


# Find in which column the desired trait is
my $trait_idx = -1;
my $trait_name = $ARGV{'t'};
my $header = <$fh>;
chomp $header;
my @fields = split /\t/, $header;
for ($trait_idx = 0; $trait_idx < scalar @fields; $trait_idx++) {
    my $field = $fields[$trait_idx];
    if ($field =~ m/^$trait_name$/i) {
        last;
    }
    if ($trait_idx == scalar @fields - 1) {
        die "Error: Could not find trait '$trait_name' in given file\n";
    }
}
warn "Info: Found trait in col ".($trait_idx+1)."\n";


# Parse input file
my %ranks;
my %dereplication;
while (my $line = <$fh>) {
    chomp $line;
    my ($gg, $trait_val) = (split /\t/, $line)[4,$trait_idx];
    my @gg_splittax  = split /;\s*/, $gg;
    if ( (scalar @gg_splittax == 1) && ($gg_splittax[0] =~ m/^-?$/) ) {
       # Skip entry with missing taxonomy string
       next;
    } elsif (scalar @gg_splittax != 7) {
        # Skip entries with malformed taxonomy string
        warn "Warning: Taxonomy string at line $. did not have 7 fields as expected. Skipping...\n";
        next;
    }
    my $derep_str = join ';', @gg_splittax[0..5];
    $dereplication{$derep_str}->{__count}++;
    $dereplication{$derep_str}->{$trait_name} += $trait_val;
    $dereplication{$derep_str}->{tax}          = \@gg_splittax;
}
close $fh;


# Calculate averages at all taxonomic levels
while (my ($derep_str, $elem) = each %dereplication) {
    my $trait_val   =   $elem->{$trait_name} / $elem->{__count};
    my @gg_splittax = @{$elem->{tax}};
    for (my $i = 1; $i <= 6; $i++) {
        my @rank_tax;
        for (my $j = 1; $j <= $i; $j++) {
            push @rank_tax, $gg_splittax[$j-1];
        }
        # Final rank must be classified
        if ($rank_tax[-1] =~ /^[kpcofgs]__$/) {
            next;
        }
        my $tax_string = join(';', @rank_tax);
        push @{$ranks{$i}->{$tax_string}}, { $trait_name => $trait_val };
    }   
}


# Writing results
my $advanced = $ARGV{'a'};
if ($advanced) {
    @fields = ('# Taxonomy', 'Num', 'Mean', 'Stddev');
} else {
    @fields = ('# Taxonomy', 'Mean');
}
print join("\t", @fields)."\n";
for my $rank (sort {$a <=> $b} keys %ranks) {
    for my $tax (sort {$a cmp $b} keys %{$ranks{$rank}}) {
        #if (scalar @{$ranks{$rank}->{$tax_string}} < 4) {
        #    # Skip clades containing with less than 4 genomes
        #    next;
        #}
        my @vals;
        for my $stats (@{$ranks{$rank}->{$tax}}) {
            push @vals, $stats->{$trait_name};
        }
        my @stats;
        if ($advanced) {
            @stats = ($tax, scalar(@vals), mean(@vals), stddev(@vals));
        } else {
            @stats = ($tax, mean(@vals));
        }
        print join("\t", @stats)."\n";
    }
    print "\n";
}

exit;
