#!/usr/bin/env perl

# trait_by_clade_weighted
# Copyright 2012 Adam Skarshewski
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade_weighted - Summarize a trait by weighted clade average

=head1 SYNOPSIS

  trait_by_clade_weighted -f trait.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and calculates its weighted average
at all taxonomic levels.

By weighted, we mean that the trait value for each clade is given the same
weight, regardless of how many sequenced genomes the trait was estimated for.
This is to prevent clade with many sequenced representative to get a
disproportionately large importance compared to clades that have few.

=head1 REQUIRED ARGUMENTS

=over

=item -i <input>

Input file of traits. This file should have been generated by the script
data_combiner.

=for Euclid:
   input.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -t <trait>

If the input file contains several trait, select the name of the trait to use
(case-insensitive), e.g. '16S count' or 'genome length'. Make sure this matches
the name of the trait as found in the input file. Default: trait.default

=for Euclid:
   trait.type: string
   trait.default: '16S Count'

=item -a <advanced>

Use advanced output: 1 is yes, 0 is no. The basic output is a tab-delimited file
with two columns, suitable for use in Copyrighter: Taxonomy, Mean. The advanced
output contains additional information distributed over four columns: Taxonomy,
Num, Mean, Stddev. Default: advanced.default

=for Euclid:
   advanced.type: integer, advanced == 0 || advanced == 1
   advanced.default: 0

=back

=head1 AUTHOR

Adam Skarshewski

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Adam Skarshewski

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use List::Util qw(sum);
use Getopt::Euclid qw(:minimal_keys);
use Statistics::Basic qw(mean stddev);
$Statistics::Basic::IPRES = 14;


open(my $fh, '<', $ARGV{'i'}) or die "Error: Could not read file ".$ARGV{'i'}."\n$!\n";


# Find in which column the desired trait is
my $trait_idx = -1;
my $trait_name = $ARGV{'t'};
my $header = <$fh>;
chomp $header;
my @fields = split /\t/, $header;
for ($trait_idx = 0; $trait_idx < scalar @fields; $trait_idx++) {
    my $field = $fields[$trait_idx];
    if ($field =~ m/^$trait_name$/i) {
        last;
    }
    if ($trait_idx == scalar @fields - 1) {
        die "Error: Could not find trait '$trait_name' in given file\n";
    }
}
warn "Info: Found trait in col ".($trait_idx+1)."\n";


# Parse input file
my @dereplication = ({}, {}, {}, {}, {}, {}, {});
while (my $line = <$fh>) {
    chomp $line;
    my ($gg, $trait_val) = (split /\t/, $line)[4,$trait_idx];
    my @gg_splittax  = split /;\s*/, $gg;
    if ( (scalar @gg_splittax == 1) && ($gg_splittax[0] =~ m/^-?$/) ) {
       # Skip entry with missing taxonomy string
       next;
    } elsif (scalar @gg_splittax != 7) {
        # Skip entries with malformed taxonomy string
        warn "Warning: Taxonomy string at line $. did not have 7 fields as expected. Skipping...\n";
        next;
    }
    # As we are averaging nodes of nodes, we can't have any taxonomies that have missing information.
    if (my $bob = sum(map {$_ =~ /__$/} @gg_splittax)) {
        next;
    }
    my $derep_str = join ';', @gg_splittax[0..6];
    push @{$dereplication[6]->{$derep_str}}, $trait_val;
}
close $fh;


# Calculate averages at all taxonomic levels
for (my $i = 5; $i >= 0; $i--) {
    my $tlvl = $dereplication[$i];                                 # this level
    while (my ($low_tax, $low_r) = each %{$dereplication[$i+1]}) { # lower level
        my @split_low_tax = split /;\s*/, $low_tax;
        my $this_tax = join ';', @split_low_tax[0..$#split_low_tax-1];
        push @{$tlvl->{$this_tax}}, mean(@$low_r);
    }
}


# Writing results
my $advanced = $ARGV{'a'};
if ($advanced) {
    @fields = ('# Taxonomy', 'Num', 'Mean', 'Stddev');
} else {
    @fields = ('# Taxonomy', 'Mean');
}
print join("\t", @fields)."\n";
for my $rank_hash_ptr (@dereplication) {
    for my $tax (sort {$a cmp $b} keys %{$rank_hash_ptr}) {
        my @vals = @{$rank_hash_ptr->{$tax}};
        my @stats;
        if ($advanced) {
            @stats = ($tax, scalar(@vals), mean(@vals), stddev(@vals));
        } else {
            @stats = ($tax, mean(@vals));
        }
        print join("\t", @stats)."\n";
    }
    print "\n";
}


exit;


