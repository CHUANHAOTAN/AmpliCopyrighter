#! /usr/bin/env perl

# trait_by_clade
# Copyright 2012 Adam Skarshewski
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade - Summarize a trait by clade average

=head1 SYNOPSIS

  trait_by_clade -f trait.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes the traits of different species and makes an average at
different taxonomic level.

=head1 REQUIRED ARGUMENTS

=over

=item -i <input>

Input file of traits. This file should have been generated by the script
data_combiner.

=for Euclid:
   input.type: readable

=back

=head1 AUTHOR

Adam Skarshewski

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Adam Skarshewski

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use Getopt::Euclid qw(:minimal_keys);
use Statistics::Basic qw(mean stddev);


open(my $fh, '<', $ARGV{'i'}) or die "Error: Could not read file ".$ARGV{'i'}."\n$!\n";

my @genomes;
my %ranks;

my %dereplication;
while (my $line = <$fh>) {
    chomp $line;
    my @splitline = split /\t/, $line;
    my @img_splittax = split /;\s*/, $splitline[2];
    my @gg_splittax = split /;\s*/, $splitline[4];
    if (scalar @gg_splittax != 7) {
        next;
    }
    my $derep_str = join ';', @gg_splittax[0..5];
    #my $dereplication_string = join ';', @img_splittax[0..5];
    if (defined($dereplication{$derep_str})) {
        $dereplication{$derep_str}->{"16S_count"} += $splitline[5];
        $dereplication{$derep_str}->{genome_size} += $splitline[6];
        $dereplication{$derep_str}->{count}++;
    } else {
        $dereplication{$derep_str} = {tax => \@gg_splittax,
                                                 "16S_count" => $splitline[5],
                                                 genome_size => $splitline[6],
                                                 count => 1};
    }
}


foreach my $derep_str (keys %dereplication) {
    my @gg_splittax = @{$dereplication{$derep_str}->{tax}};
    my $count = $dereplication{$derep_str}->{count};
    my $rRNA_count = $dereplication{$derep_str}->{"16S_count"} / $count;
    my $genome_size = $dereplication{$derep_str}->{genome_size} / $count;
    for(my $i = 1; $i <= 6; $i++) {
        my @rank_tax;
        for (my $j = 1; $j <= $i; $j++) {
            push @rank_tax, $gg_splittax[$j-1];
        }
        # Final rank must be classified
        if ($rank_tax[-1] =~ /^[kpcofgs]__$/) {
            next;
        }
        my $tax_string = join(";", @rank_tax);
        push @{$ranks{$i}->{$tax_string}}, {genome_size => $genome_size,
                                            "16S_count" => $rRNA_count}
    }   
}

print join("\t", ("Taxonomy", "NumGenera", "Mean", "StdDev")), "\n";
foreach my $rank (sort {$a <=> $b} keys %ranks) {
    foreach my $tax_string (sort {$a cmp $b} keys %{$ranks{$rank}}) {
        my @genome_lengths;
        my @rRNA_counts;
        #if (scalar @{$ranks{$rank}->{$tax_string}} < 4) {
        #    next;
        #}
        foreach my $stats (@{$ranks{$rank}->{$tax_string}}) {
            push @genome_lengths, $stats->{genome_size};
            push @rRNA_counts, $stats->{"16S_count"};
        }
        print join("\t", ($tax_string, scalar @rRNA_counts, mean(@rRNA_counts), stddev(@rRNA_counts)
                          #mean(@genome_lengths), median(@genome_lengths), stddev(@genome_lengths)
                          )), "\n";
    }
    print "\n";
}

close($fh);

exit;
