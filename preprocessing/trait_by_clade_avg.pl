#!/usr/bin/env perl

# trait_by_clade_avg
# Copyright 2012 Adam Skarshewski
# You may distribute this module under the terms of the GPLv3


=head1 NAME

trait_by_clade_avg - Summarize a trait by weighted clade average

=head1 SYNOPSIS

  trait_by_clade_avg -f trait.txt > trait_summary.txt

=head1 DESCRIPTION

This script takes a trait in different species and calculates its weighted average
at all taxonomic levels.

By weighted, we mean that the trait value for each
clade is given the same weight, regardless of how many sequenced genomes the
trait was estimated from. This is to prevent clade with many sequenced
representative to get a large importance than clades for which there are few.

###XXX
###The output if a tab-delimited file with 5 columns:
###Taxonomy, Num, Mean, Stddev.
###XXX

=head1 REQUIRED ARGUMENTS

=over

=item -i <input>

Input file of traits. This file should have been generated by the script
data_combiner.

=for Euclid:
   input.type: readable

=back

=head1 OPTIONAL ARGUMENTS

=over

=item -t <trait>

If the input file contains several trait, select the name of the trait to use
(case-insensitive), e.g. '16S count' or 'genome length'. Make sure this matches
the name of the trait as found in the input file. Default: trait.default

=for Euclid:
   trait.type: string
   trait.default: '16S Count'

=back

=head1 AUTHOR

Adam Skarshewski

=head1 BUGS

All complex software has bugs lurking in it, and this program is no exception.
If you find a bug, please report it on the bug tracker:
L<http://github.com/fangly/AmpliCopyrighter/issues>

=head1 COPYRIGHT

Copyright 2012 Adam Skarshewski

Copyrighter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
Copyrighter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Copyrighter.  If not, see <http://www.gnu.org/licenses/>.

=cut


use strict;
use warnings;
use List::Util qw(sum);
use Getopt::Euclid qw(:minimal_keys);


open(my $fh, '<', $ARGV{'i'}) or die "Error: Could not read file ".$ARGV{'i'}."\n$!\n";


# Find in which column the desired trait is
my $trait_idx = -1;
my $trait_name = $ARGV{'t'};
my $header = <$fh>;
chomp $header;
my @fields = split /\t/, $header;
for ($trait_idx = 0; $trait_idx < scalar @fields; $trait_idx++) {
    my $field = $fields[$trait_idx];
    if ($field =~ m/^$trait_name$/i) {
        last;
    }
    if ($trait_idx == scalar @fields - 1) {
        die "Error: Could not find trait '$trait_name' in given file\n";
    }
}
warn "Info: Found trait in col ".($trait_idx+1)."\n";


# Parse input file
my @dereplication = ({},{},{},{},{},{},{});
while (my $line = <$fh>) {
    chomp $line;
    my ($gg, $trait_val) = (split /\t/, $line)[4,$trait_idx];
    my @gg_splittax  = split /;\s*/, $gg;
    if (scalar @gg_splittax != 7) {
        # Skip entries with missing or malformed taxonomy string
        next;
    }
    # As we are averaging nodes of nodes, we can't have any taxonomies that have missing information.
    if (my $bob = sum(map {$_ =~ /__$/} @gg_splittax)) {
        next;
    }
    my $derep_str = join ';', @gg_splittax[0..6];
    $dereplication[6]->{$derep_str}->{$trait_name} += $trait_val;
    $dereplication[6]->{$derep_str}->{__count}++;
}
close($fh);


# Calculate averages at all taxonomic levels
for (my $i = 5; $i >= 0; $i--) {
    my $tlvl = $dereplication[$i];                                 # this level
    while (my ($low_tax, $low_h) = each %{$dereplication[$i+1]}) { # lower level
        my @split_low_tax = split /;\s*/, $low_tax;
        my $this_tax = join ';', @split_low_tax[0..$#split_low_tax-1];
        $tlvl->{$this_tax}->{$trait_name} += $low_h->{$trait_name} / $low_h->{__count};
        $tlvl->{$this_tax}->{__count}++;
    }
}


# Writing results
###print join("\t", "# Taxonomy", "Num", "Mean", "Stddev"), "\n";
print join("\t", "# Taxonomy", "Num", "Mean"), "\n";
for my $rank_hash_ptr (@dereplication) {
    for my $tax (sort {$a cmp $b} keys %{$rank_hash_ptr}) {
        my $l = $rank_hash_ptr->{$tax};
        print join("\t", $tax, $l->{__count}, $l->{$trait_name}/$l->{__count})."\n";
    }
    print "\n";
}


exit;


